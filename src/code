* { margin: 0; padding: 0; box-sizing: border-box; } body { font-family: Arial, sans-serif; line-height: 1.6; background-color: #f4f4f4; } header { background-color: #F4A259; color: #333; padding: 20px 0; text-align: center; } header .logo { width: 100px; height: auto; margin-top: 10px; border-radius: 50%; } .container { width: 80%; margin: auto; overflow: hidden; } .features, .expense-tracker { padding: 20px 0; background: #f4f4f4; text-align: center; } .features h2, .expense-tracker h2 { text-align: center; margin-bottom: 20px; color: #333; } .features ul { list-style: none; padding: 0; text-align: center; display: inline-block; } .features li { padding: 10px; background: #F4A259; margin-bottom: 10px; border: 1px solid #ddd; border-radius: 4px; } .expense-tracker { max-width: 600px; margin: 70px auto; padding: 50px; background-color: #F4E285; box-shadow: 0 0 10px rgba(0, 0, 0, 0.5); border: 2px solid #F4A259; border-radius: 300px; } .expense-tracker input[type="text"], .expense-tracker input[type="number"] { width: 100%; padding: 8px; box-sizing: border-box; border: 1px solid #ccc; border-radius: 40px; } button { display: inline-block; padding: 10px 15px; margin-right: 10px; background-color: #28a745; color: #fff; border: 10 px; border-radius: 40px; cursor: pointer; } button:hover { background-color: #218838; } pre { background-color: #f8f9fa; border: 0px solid #ccc; border-radius: 4px; white-space: pre-wrap; word-wrap: break-word; } footer { background: #333; color: white; text-align: center; padding: 10px 0; margin-top: 20px; } @media (max-width: 768px) { .container { width: 95%; } header .logo { width: 80px; } } Keep this portion of css data unchange and add some more festure as shown in the uploaded picture. For the describtion of how it works see the code below. use std::collections::HashMap; use std::fs::File; use std::io::{self, Write}; use std::path::Path; struct ExpenseTracker { expenses: HashMap<String, f64>, } impl ExpenseTracker { fn new() -> Self { ExpenseTracker { expenses: HashMap::new(), } } fn add_expense(&mut self, category: String, amount: f64) { let counter = self.expenses.entry(category).or_insert(0.0); *counter += amount; } fn view_report(&self) { println!("Expenses Report:"); for (category, amount) in &self.expenses { println!("{}: {:.2}", category, amount); } } fn export_to_csv(&self, filename: &str) { let path = Path::new(filename); let display = path.display(); let mut file = match File::create(&path) { Err(why) => panic!("couldn't create {}: {}", display, why), Ok(file) => file, }; for (category, amount) in &self.expenses { if let Err(why) = writeln!(file, "{},{}", category, amount) { panic!("couldn't write to {}: {}", display, why) } } println!("Data exported to {}", filename); } } fn main() { let mut tracker = ExpenseTracker::new(); loop { println!("Choose an option: (1) Add Expense (2) View Report (3) Export to CSV (4) Exit"); let mut choice = String::new(); io::stdin().read_line(&mut choice).expect("Failed to read line"); let choice: u32 = choice.trim().parse().expect("Invalid input"); match choice { 1 => { let mut category = String::new(); let mut amount = String::new(); println!("Enter category:"); io::stdin().read_line(&mut category).expect("Failed to read line"); println!("Enter amount:"); io::stdin().read_line(&mut amount).expect("Failed to read line"); let amount: f64 = amount.trim().parse().expect("Invalid input"); tracker.add_expense(category.trim().to_string(), amount); } 2 => { tracker.view_report(); } 3 => { println!("Enter filename to export to (e.g., expenses.csv):"); let mut filename = String::new(); io::stdin().read_line(&mut filename).expect("Failed to read line"); tracker.export_to_csv(filename.trim()); } 4 => break, _ => println!("Invalid choice!"), } } }